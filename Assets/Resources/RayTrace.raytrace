#pragma max_recursion_depth 11

#include "./../Shaders/Common.hlsl"
#include "./../Shaders/DirectRays.hlsl"
#include "./../Shaders/Shadows.hlsl"

// Input
Texture2D<float4> GBufferNormalsAndMaterials;
Texture2D<float4> GBufferPositionsAndDepth;
// Output
RWTexture2D<float4> _OutputTarget;
RWTexture2D<float4> _OutputTarget2;
// Variables
int _FrameIndex;
int _FrameCounter;
int _DepthOfRecursion;
float3 LightPosition;
float LightProgress;

int SoftShadowsOn;
int IndirectLightingOn;

[shader("raygeneration")]
void DirectAndIndirectRaygenShader()
{
	const uint2 dispatchIdx = DispatchRaysIndex().xy;
	const uint2 dispatchDim = DispatchRaysDimensions();

	// Load the position and normal from our g-buffer
	float4 worldPos = GBufferPositionsAndDepth[dispatchIdx];
	
	if (worldPos.w == 0.0f)
	{
		_OutputTarget[dispatchIdx] = float4(1.0f, 1.0f, 1.0f, 1.0f);
		_OutputTarget2[dispatchIdx] = float4(1.0f, 1.0f, 1.0f, 1.0f);
		return;
	}

	float3 worldNorm = GBufferNormalsAndMaterials[dispatchIdx].xyz;

	uint randSeed = initRand(dispatchIdx.x + dispatchIdx.y * dispatchDim.x, _FrameCounter, 16);

	float4 color = (0, 0, 0, 0);
	float primary = 0.0f;
	float sunSize = 100.0f;
	float3 indirect = float3(0.0f, 0.0f, 0.0f);

	float numOfIters = 4.0f;
	float lightIntensity = 4.0f;

	for (int i = 0; i < (int)numOfIters; i++)
	{
		// Sample cosine-weighted hemisphere around surface normal to pick a random ray direction
		float3 worldDir = getCosHemisphereSample(randSeed, worldNorm);

		if (IndirectLightingOn > 0)
			indirect += shootDirectLightRay(worldPos.xyz, worldDir, 1e-5f, 40, 1, randSeed);

		if (LightProgress < 0.6f || LightProgress > 0.6f)
		{
			float distToLight;
			float3 dirToLight = normalize(LightPosition - worldPos);
			if (SoftShadowsOn > 0)
			{
				float3 sampleOnHemisphere = LightPosition + sunSize * GetPointOnSphere(randSeed);
				dirToLight = normalize(sampleOnHemisphere - worldPos);
				distToLight = length(sampleOnHemisphere - worldPos) - 0.2f;
			}
			else
				distToLight = length(LightPosition - worldPos) - 0.2f;
			float nDotL = max(0.3f, dot(worldNorm, dirToLight));

			// Shoot shadow ray with our encapsulated shadow tracing function
			float shadow = shootShadowRay(worldPos + worldNorm * 0.001f, dirToLight, 1.0e-4f, distToLight);
			primary += nDotL * max(0.2f, shadow);
		}
		else
		{
			float3 dirToLight = normalize(LightPosition - worldPos);
			float nDotL = max(0.3f, dot(worldNorm, dirToLight));
			float shadow = 0.0f;
			primary += max(0.1f, shadow);
		}
	}

	float shadow = max(0.f, (primary / numOfIters));// *0.5f * secondary;
	color = float4(shadow, shadow, shadow, 1);

	if (_FrameIndex > 1)
	{
		float a = 1.0f / (float)_FrameIndex;
		color = _OutputTarget[dispatchIdx] * (1.0f - a) + color * a;
	}

	_OutputTarget[dispatchIdx] = color;
	if (IndirectLightingOn > 0)
		_OutputTarget2[dispatchIdx] = float4(indirect / numOfIters, 1);
}

[shader("miss")]
void MissShader(inout RayPayload rayPayload : SV_RayPayload)
{
	float3 origin = WorldRayOrigin();
	float3 direction = WorldRayDirection();
	//rayPayload.color = 0.2f * float4(BackgroundColor(origin, direction, LightProgress), 1.0f);
	rayPayload.color = float4(0.0f, 0.0f, 0.0f, 1.0f);
}

[shader("miss")]
void ShadowMiss(inout RayPayloadShadow shadowRayPayload : SV_RayPayload) {
    shadowRayPayload.visibility = 1.0f;
}

[shader("anyhit")]
void AnyHitShader(inout RayPayload rayPayload : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
{
	AcceptHitAndEndSearch();
}