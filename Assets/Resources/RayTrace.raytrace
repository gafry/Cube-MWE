#pragma max_recursion_depth 11

#include "./../Shaders/Common.hlsl"
#include "./../Shaders/DirectRays.hlsl"
#include "./../Shaders/Shadows.hlsl"

RWTexture2D<float4> _OutputTarget;
RWTexture2D<float4> _OutputTarget2;
int _FrameIndex;
int _FrameCounter;
int _DepthOfRecursion;
float3 LightPosition;
Texture2D<float4> GBufferNormals;
Texture2D<float4> Position;
int SoftShadowsOn;
int IndirectLightingOn;

[shader("raygeneration")]
void DirectRaygenShader()
{
	const uint2 dispatchIdx = DispatchRaysIndex().xy;
	const uint2 dispatchDim = DispatchRaysDimensions();

	// Load the position and normal from our g-buffer
	float4 worldPos = Position[dispatchIdx];
	
	if (worldPos.w == 0.0f)
	{
		_OutputTarget[dispatchIdx] = float4(1.0f, 1.0f, 1.0f, 1.0f);
		_OutputTarget2[dispatchIdx] = float4(1.0f, 1.0f, 1.0f, 1.0f);
		return;
	}

	float4 worldNorm = GBufferNormals[dispatchIdx];

	uint randSeed = initRand(dispatchIdx.x + dispatchIdx.y * dispatchDim.x, _FrameCounter, 16);

	float4 color = (0, 0, 0, 0);
	float primary = 0.0f;
	float sunSize = 100.0f;
	float3 indirect = float3(0.0f, 0.0f, 0.0f);

	float numOfIters = 4.0f;
	float lightIntensity = 4.0f;
	/*if (worldPos.w > 40)
		numOfIters = 3;
	else if (worldPos.w > 80)
		numOfIters = 2;
	else if (worldPos.w > 120)
		numOfIters = 1;*/

	for (int i = 0; i < (int)numOfIters; i++)
	{
		// Sample cosine-weighted hemisphere around surface normal to pick a random ray direction
		float3 worldDir = getCosHemisphereSample(randSeed, worldNorm.xyz);

		if (IndirectLightingOn > 0)
			indirect += shootDirectLightRay(worldPos.xyz, worldDir, 1e-5f, 20, 1, randSeed);

		if (LightPosition.y + sunSize > 0)
		{
			float distToLight;
			float3 dirToLight = normalize(LightPosition - worldPos);
			if (SoftShadowsOn > 0)
			{
				float3 sampleOnHemisphere = LightPosition + sunSize * SampleHemisphereCosine(randSeed, dirToLight);
				dirToLight = normalize(sampleOnHemisphere - worldPos);
				distToLight = length(sampleOnHemisphere - worldPos) - 0.2f;
			}
			else
				distToLight = length(LightPosition - worldPos) - 0.2f;
			float nDotL = max(0.f, dot(worldNorm, dirToLight));

			// Shoot shadow ray with our encapsulated shadow tracing function
			float shadow = shootShadowRay(worldPos, dirToLight, 1.0e-4f, distToLight);
			primary += nDotL * max(0.1f, shadow);
		}
		else
		{
			float3 dirToLight3 = normalize(LightPosition - worldPos);
			float3 sampleOnHemisphere = LightPosition + sunSize * SampleHemisphereCosine(randSeed, dirToLight3);
			dirToLight3 = normalize(sampleOnHemisphere - worldPos);
			float distToLight3 = length(sampleOnHemisphere - worldPos) - 0.2f;
			float nDotL = max(0.f, dot(worldNorm, dirToLight3));

			float shadow = 0.0f;
			primary += 0.1f;//nDotL * max(0.1f, shadow);
		}
	}

	float shadow = max(0.f, (primary / numOfIters));// *0.5f * secondary;
	color = float4(shadow, shadow, shadow, 1);

	if (_FrameIndex > 1)
	{
		float a = 1.0f / (float)_FrameIndex;
		color = _OutputTarget[dispatchIdx] * (1.0f - a) + color * a;
	}

	_OutputTarget[dispatchIdx] = color;
	if (IndirectLightingOn > 0)
		_OutputTarget2[dispatchIdx] = float4(indirect / numOfIters, 1);
}

[shader("miss")]
void MissShader(inout RayPayload rayPayload : SV_RayPayload)
{
	float3 origin = WorldRayOrigin();
	float3 direction = WorldRayDirection();
	rayPayload.color = 0.2f * float4(BackgroundColor(origin, direction), 1.0f);
	//rayPayload.color = float4(0.0f, 0.0f, 0.0f, 1.0f);
}

[shader("miss")]
void ShadowMiss(inout RayPayloadShadow shadowRayPayload : SV_RayPayload) {
    shadowRayPayload.visibility = 1.0f;
}

[shader("anyhit")]
void AnyHitShader(inout RayPayload rayPayload : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
{
	AcceptHitAndEndSearch();
}