// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ATrous

// Group size
#define size_x 24
#define size_y 24

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> ShadowInput;
Texture2D<float4> Position;
Texture2D<float4> GBufferNormals;
Texture2D<float4> HistoryBuffer;
RWTexture2D<float4> FilteredOutput;
float CameraX;
float CameraY;
float StepWidth;
bool Variance;
uint Iteration;

static const float aTrousFilter3x3[3][3] =
{
    0.0625, 0.125, 0.0625,
    0.125, 0.25, 0.125,
    0.0625, 0.125, 0.0625
};

static const float aTrousFilter5x5[5][5] =
{
    1.0 / 256.0, 1.0 / 64.0, 3.0 / 128.0, 1.0 / 64.0, 1.0 / 256.0,
    1.0 / 64.0, 1.0 / 16.0, 3.0 / 32.0, 1.0 / 16.0, 1.0 / 64.0,
    3.0 / 128.0, 3.0 / 32.0, 9.0 / 64.0, 3.0 / 32.0, 3.0 / 128.0,
    1.0 / 64.0, 1.0 / 16.0, 3.0 / 32.0, 1.0 / 16.0, 1.0 / 64.0,
    1.0 / 256.0, 1.0 / 64.0, 3.0 / 128.0, 1.0 / 64.0, 1.0 / 256.0
};

static const float gaussianFilter[3][3] =
{
    { 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 },
    { 1.0 / 8.0,  1.0 / 4.0, 1.0 / 8.0  },
    { 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 }
};

static const float gaussianFilter5x5[5][5] =
{
    { 1.0 / 273.0, 4.0 / 273.0, 7.0 / 273.0, 4.0 / 273.0, 1.0 / 273.0 },
    { 4.0 / 273.0, 16.0 / 273.0, 26.0 / 273.0, 16.0 / 273.0, 4.0 / 273.0 },
    { 7.0 / 273.0, 26.0 / 273.0, 41.0 / 273.0, 26.0 / 273.0, 7.0 / 273.0 },
    { 4.0 / 273.0, 16.0 / 273.0, 26.0 / 273.0, 16.0 / 273.0, 4.0 / 273.0 },
    { 1.0 / 273.0, 4.0 / 273.0, 7.0 / 273.0, 4.0 / 273.0, 1.0 / 273.0 }
};

static const float offset[25][2] =
{
    { -2, -2 },
    { -1, -2 },
    {  0, -2 },
    {  1, -2 },
    {  2, -2 },

    { -2, -1 },
    { -1, -1 },
    {  0, -1 },
    {  1, -1 },
    {  2, -1 },

    { -2,  0 },
    { -1,  0 },
    {  0,  0 },
    {  1,  0 },
    {  2,  0 },

    { -2,  1 },
    { -1,  1 },
    {  0,  1 },
    {  1,  1 },
    {  2,  1 },

    { -2,  2 },    
    { -1,  2 },
    {  0,  2 },
    {  1,  2 },
    {  2,  2 }
};

static const float offset3x3[9][2] =
{
    { -1, -1 },
    {  0, -1 },
    {  1, -1 },

    { -1,  0 },
    {  0,  0 },
    {  1,  0 },

    { -1,  1 },    
    {  0,  1 },    
    {  1,  1 },
};

void ATrousIxI(uint3 dispatchThreadId, float4 positionValue, float4 shadowValue, int size)
{
    /*float ShadowPhi = 1 / Iteration * 3.3f;
    float PositionPhi = 1 / float(1 << Iteration) * 0.005f;
    float NormalPhi = 1 / float(1 << Iteration) * 1e-2f;*/
    float ShadowPhi = 1.0;
    float PositionPhi = 0.3;
    float NormalPhi = 0.5;

    float4 sum = float4(0, 0, 0, 0);
    float4 normalValue = float4(GBufferNormals.Load(dispatchThreadId).xyz, 1.0f);

    float cumW = 0.0f;
    float weight = 0.0f;
    float shadowW = 0.0f;
    float normalW = 0.0f;
    float positionW = 0.0f;
    float4 t = 0.0f;
    float distance2 = 0.0f;
    for (int x = (size - 1) / 2; x <= (size - 1) / 2; x++)
    {
        for (int y = (size - 1) / 2; y <= (size - 1) / 2; y++)
        {
            int3 uv = dispatchThreadId + int3(x, y, 0) * StepWidth;

            if (uv.x < 0 || uv.x >= CameraX || uv.y < 0 || uv.y >= CameraY)
                continue;

            // shadow
            float4 shadowTmp = ShadowInput.Load(uv);
            t = shadowValue - shadowTmp;
            distance2 = dot(t, t);
            shadowW = min(exp(-(distance2) / ShadowPhi), 1.0f);

            // normal
            float4 normalTmp = float4(GBufferNormals.Load(uv).xyz, 1.0f);
            t = normalValue - normalTmp;
            distance2 = max(dot(t, t), 0.0f);
            if (distance2 > 0.8)
                continue;
            normalW = min(exp(-(distance2) / NormalPhi), 1.0f);

            // Position
            float4 positionTmp = float4(Position.Load(uv).xyz, 1.0f);
            float3 heading;
            heading.x = positionValue.x - positionTmp.x;
            heading.y = positionValue.y - positionTmp.y;
            heading.z = positionValue.z - positionTmp.z;
            float distanceSquared = heading.x * heading.x + heading.y * heading.y + heading.z * heading.z;
            float distance = sqrt(distanceSquared);
            if (distance > 0.3f)
                continue;

            float weightedKernel = shadowW * normalW * aTrousFilter3x3[x][y];
            sum += shadowTmp * weightedKernel;
            cumW += weightedKernel;
        }
    }

    FilteredOutput[dispatchThreadId.xy] = sum / cumW;
    float4 result = sum / cumW;
}

// Declare one thread for each texel of the current block size.
void ATrous5x5(uint3 dispatchThreadId, float4 positionValue, float4 shadowValue)
{
    /*float ShadowPhi = 1 / Iteration * 3.3f;
    float PositionPhi = 1 / float(1 << Iteration) * 0.005f;
    float NormalPhi = 1 / float(1 << Iteration) * 1e-2f;*/
    float ShadowPhi = 1.0;
    float PositionPhi = 0.3;
    float NormalPhi = 0.5;

    float4 sum = float4(0, 0, 0, 0);
    float4 normalValue = float4(GBufferNormals.Load(dispatchThreadId).xyz, 1.0f);

    float cumW = 0.0f;
    float weight = 0.0f;
    float shadowW = 0.0f;
    float normalW = 0.0f;
    float positionW = 0.0f;
    float4 t = 0.0f;
    float distance2 = 0.0f;

    for (int x = 0; x < 5; x++)
    {
        for (int y = 0; y < 5; y++)
        {
            int i = 5 * x + y;
            int3 uv = dispatchThreadId + int3(offset[i][0], offset[i][1], 0) * StepWidth;

            if (uv.x < 0 || uv.x >= CameraX || uv.y < 0 || uv.y >= CameraY)
            {
                continue;
            }

            // shadow
            float4 shadowTmp = ShadowInput.Load(uv);
            t = shadowValue - shadowTmp;
            distance2 = dot(t, t);
            shadowW = min(exp(-(distance2) / ShadowPhi), 1.0f);

            // normal
            float4 normalTmp = float4(GBufferNormals.Load(uv).xyz, 1.0f);
            t = normalValue - normalTmp;
            distance2 = max(dot(t, t), 0.0f);
            if (distance2 > 0.8)
                continue;
            normalW = min(exp(-(distance2) / NormalPhi), 1.0f);

            // Position
            float4 positionTmp = float4(Position.Load(uv).xyz, 1.0f);
            float3 heading;
            heading.x = positionValue.x - positionTmp.x;
            heading.y = positionValue.y - positionTmp.y;
            heading.z = positionValue.z - positionTmp.z;
            float distanceSquared = heading.x * heading.x + heading.y * heading.y + heading.z * heading.z;
            float distance = sqrt(distanceSquared);
            if (distance > 0.1f)
                continue;

            float weightedKernel = shadowW * normalW * aTrousFilter5x5[x][y];
            sum += shadowTmp * weightedKernel;
            cumW += weightedKernel;
        }
    }

    FilteredOutput[dispatchThreadId.xy] = sum / cumW;
    //FilteredOutput[dispatchThreadId.xy] = float4(normalW, normalW, normalW, 1);
}

void ATrous3x3(uint3 dispatchThreadId, float4 positionValue, float4 shadowValue)
{
    /*float ShadowPhi = 1 / Iteration * 3.3f;
    float PositionPhi = 1 / float(1 << Iteration) * 0.005f;
    float NormalPhi = 1 / float(1 << Iteration) * 1e-2f;*/
    float ShadowPhi = 1.0;
    float PositionPhi = 0.3;
    float NormalPhi = 0.5;

    float4 sum = float4(0, 0, 0, 0);
    float4 normalValue = float4(GBufferNormals.Load(dispatchThreadId).xyz, 1.0f);

    float cumW = 0.0f;
    float weight = 0.0f;
    float shadowW = 0.0f;
    float normalW = 0.0f;
    float positionW = 0.0f;
    float4 t = 0.0f;
    float distance2 = 0.0f;
    for (int x = 0; x < 3; x++)
    {
        for (int y = 0; y < 3; y++)
        {
            int i = 3 * x + y;
            int3 uv = dispatchThreadId + int3(offset3x3[i][0], offset3x3[i][1], 0) * StepWidth;

            if (uv.x < 0 || uv.x >= CameraX || uv.y < 0 || uv.y >= CameraY)
            {
                continue;
            }

            // shadow
            float4 shadowTmp = ShadowInput.Load(uv);
            t = shadowValue - shadowTmp;
            distance2 = dot(t, t);
            shadowW = min(exp(-(distance2) / ShadowPhi), 1.0f);

            // normal
            float4 normalTmp = float4(GBufferNormals.Load(uv).xyz, 1.0f);
            t = normalValue - normalTmp;
            distance2 = max(dot(t, t), 0.0f);
            if (distance2 > 0.8)
                continue;
            normalW = min(exp(-(distance2) / NormalPhi), 1.0f);

            // Position
            float4 positionTmp = float4(Position.Load(uv).xyz, 1.0f);
            float3 heading;
            heading.x = positionValue.x - positionTmp.x;
            heading.y = positionValue.y - positionTmp.y;
            heading.z = positionValue.z - positionTmp.z;
            float distanceSquared = heading.x * heading.x + heading.y * heading.y + heading.z * heading.z;
            float distance = sqrt(distanceSquared);
            if (distance > 0.1f)
                continue;

            float weightedKernel = shadowW * normalW * aTrousFilter3x3[x][y];
            sum += shadowTmp * weightedKernel;
            cumW += weightedKernel;
        }
    }

    FilteredOutput[dispatchThreadId.xy] = sum / cumW;
    float4 result = sum / cumW;
}

[numthreads(size_x, size_y, 1)]
void ATrous(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    float4 shadowValue = ShadowInput.Load(dispatchThreadId);
    float4 positionValue = Position.Load(dispatchThreadId);
    float4 historyValue = HistoryBuffer.Load(dispatchThreadId);

    float distance = positionValue.w;

    positionValue = float4(positionValue.x, positionValue.y, positionValue.z, 1.0f);

    if (historyValue.x < 0.09f && Iteration > 2 && Variance)
    {
        FilteredOutput[dispatchThreadId.xy] = shadowValue;
    }
    /*else if (historyValue.x < 0.24922f)
    {
        if (Iteration < 3)
            ATrous3x3(dispatchThreadId, positionValue, shadowValue);
        else if (Iteration < 7)
            ATrous5x5(dispatchThreadId, positionValue, shadowValue);
        else
            FilteredOutput[dispatchThreadId.xy] = shadowValue;
    }*/
    else if (Iteration > 4)
    {
        ATrous3x3(dispatchThreadId, positionValue, shadowValue);
    }
    else
    {
        ATrous5x5(dispatchThreadId, positionValue, shadowValue);
    }
}