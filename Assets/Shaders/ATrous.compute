// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ATrous

// Group size
#define size_x 24
#define size_y 24

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> ShadowInput;
Texture2D<float4> Position;
Texture2D<float4> GBufferNormals;
Texture2D<float4> HistoryBuffer;
RWTexture2D<float4> FilteredOutput;
float CameraX;
float CameraY;
float StepWidth;
bool Variance;
uint Iteration;
float AdaptCoef;
float _CameraFarDistance;

static const float aTrousFilter3x3[3][3] =
{
    0.0625, 0.125, 0.0625,
    0.125, 0.25, 0.125,
    0.0625, 0.125, 0.0625
};

static const float aTrousFilter5x5[5][5] =
{
    1.0 / 256.0, 1.0 / 64.0, 3.0 / 128.0, 1.0 / 64.0, 1.0 / 256.0,
    1.0 / 64.0, 1.0 / 16.0, 3.0 / 32.0, 1.0 / 16.0, 1.0 / 64.0,
    3.0 / 128.0, 3.0 / 32.0, 9.0 / 64.0, 3.0 / 32.0, 3.0 / 128.0,
    1.0 / 64.0, 1.0 / 16.0, 3.0 / 32.0, 1.0 / 16.0, 1.0 / 64.0,
    1.0 / 256.0, 1.0 / 64.0, 3.0 / 128.0, 1.0 / 64.0, 1.0 / 256.0
};

static const float gaussianFilter[3][3] =
{
    { 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 },
    { 1.0 / 8.0,  1.0 / 4.0, 1.0 / 8.0  },
    { 1.0 / 16.0, 1.0 / 8.0, 1.0 / 16.0 }
};

static const float gaussianFilter5x5[5][5] =
{
    { 1.0 / 273.0, 4.0 / 273.0, 7.0 / 273.0, 4.0 / 273.0, 1.0 / 273.0 },
    { 4.0 / 273.0, 16.0 / 273.0, 26.0 / 273.0, 16.0 / 273.0, 4.0 / 273.0 },
    { 7.0 / 273.0, 26.0 / 273.0, 41.0 / 273.0, 26.0 / 273.0, 7.0 / 273.0 },
    { 4.0 / 273.0, 16.0 / 273.0, 26.0 / 273.0, 16.0 / 273.0, 4.0 / 273.0 },
    { 1.0 / 273.0, 4.0 / 273.0, 7.0 / 273.0, 4.0 / 273.0, 1.0 / 273.0 }
};

float NormalEdgeStopping(float3 normalValue, float3 normalTmp)
{
    return pow(max(0, dot(normalValue, normalTmp)), 128);
}

bool WorldPositionEdgeStopping(float3 positionValue, float3 positionTmp, int stepSize, float t)
{
    float3 heading;
    heading.x = positionValue.x - positionTmp.x;
    heading.y = positionValue.y - positionTmp.y;
    heading.z = positionValue.z - positionTmp.z;
    float distanceSquared = heading.x * heading.x + heading.y * heading.y + heading.z * heading.z;
    float distance = sqrt(distanceSquared);
    return distance > 0.3f;//max(0.9f, (t / _CameraFarDistance) * 4.20f);

    /*float3 heading;
    heading.x = positionValue.x - positionTmp.x;
    heading.y = positionValue.y - positionTmp.y;
    heading.z = positionValue.z - positionTmp.z;
    float distanceSquared = heading.x * heading.x + heading.y * heading.y + heading.z * heading.z;
    float distance = sqrt(distanceSquared);
    return distance / max(stepSize * AdaptCoef, 1e-8);*/
}

void ATrousIxI(uint3 dispatchThreadId, float4 positionValue, float4 shadowValue, int size)
{
    /*float ShadowPhi = 1 / Iteration * 3.3f;
    float PositionPhi = 1 / float(1 << Iteration) * 0.005f;
    float NormalPhi = 1 / float(1 << Iteration) * 1e-2f;*/
    float ShadowPhi = 1.0;
    float PositionPhi = 0.3;
    float NormalPhi = 0.5;

    float4 sum = float4(0, 0, 0, 0);
    //float3 normalValue = GBufferNormals.Load(dispatchThreadId).xyz;
    float4 normalValue = float4(GBufferNormals.Load(dispatchThreadId).xyz, 1.0f);

    float cumW = 0.0f;
    float weight = 0.0f;
    float shadowW = 0.0f;
    float normalW = 0.0f;
    float positionW = 0.0f;
    float4 t = 0.0f;
    float distance2 = 0.0f;
    int i = (size - 1) / 2;
    for (int x = -i; x <= i; x++)
    {
        for (int y = -i; y <= i; y++)
        {
            int3 uv = dispatchThreadId + int3(x, y, 0) * StepWidth;

            if (uv.x < 0 || uv.x >= CameraX || uv.y < 0 || uv.y >= CameraY)
                continue;

            // Position
            float3 positionTmp = Position.Load(uv).xyz;
            if (WorldPositionEdgeStopping(float3(positionValue.xyz), positionTmp, StepWidth, positionValue.w))
                continue;

            // normal
            /*float3 normalTmp = GBufferNormals.Load(uv).xyz;
            normalW = NormalEdgeStopping(float3(normalValue.xyz), normalTmp);*/
            float4 normalTmp = float4(GBufferNormals.Load(uv).xyz, 1.0f);
            t = normalValue - normalTmp;
            distance2 = max(dot(t, t), 0.0f);
            normalW = min(exp(-(distance2) / NormalPhi), 1.0f);
            if (distance2 > 0.8 || normalW == 0)
                continue;

            // shadow
            float4 shadowTmp = ShadowInput.Load(uv);
            t = shadowValue - shadowTmp;
            distance2 = dot(t, t);
            shadowW = min(exp(-(distance2) / ShadowPhi), 1.0f);            

            float weightedKernel; 
            if (size == 3)
                weightedKernel = shadowW * normalW * aTrousFilter3x3[x + i][y + i];
            else
                weightedKernel = shadowW * normalW * aTrousFilter5x5[x + i][y + i];
            sum += shadowTmp * weightedKernel;
            cumW += weightedKernel;
        }
    }

    FilteredOutput[dispatchThreadId.xy] = sum / cumW;
    float4 result = sum / cumW;
}

[numthreads(size_x, size_y, 1)]
void ATrous(uint3 dispatchThreadId : SV_DispatchThreadID)
{
    float4 shadowValue = ShadowInput.Load(dispatchThreadId);
    float4 positionValue = Position.Load(dispatchThreadId);
    float4 historyValue = HistoryBuffer.Load(dispatchThreadId);

    float distance = positionValue.w;
    /* Depth buffer */
    /*FilteredOutput[dispatchThreadId.xy] = float4(positionValue.w / _CameraFarDistance, positionValue.w / _CameraFarDistance, positionValue.w / _CameraFarDistance, 1);
    return;*/

    //positionValue = float4(positionValue.x, positionValue.y, positionValue.z, 1.0f);

    if (distance == 0.f)
    {
        FilteredOutput[dispatchThreadId.xy] = float4(1, 1, 1, 1);
    }
    else if (historyValue.x <= 0.05595371872186661f && Iteration > 2 && Variance)
    {
        FilteredOutput[dispatchThreadId.xy] = shadowValue;
    }
    /*else if (Iteration > 4)
    {
        ATrousIxI(dispatchThreadId, positionValue, shadowValue, 3);
    }*/
    else
    {
        ATrousIxI(dispatchThreadId, positionValue, shadowValue, 5);
    }
}